<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tetris</title>
  <style>
    body { font-family: "Trebuchet MS", Arial, sans-serif; background:#f5f2e8; color:#1f1f1f; display:flex; align-items:center; justify-content:center; min-height:100vh; margin:0; }
    .wrap { text-align:center; }
    canvas { background:#fff; border:3px solid #1f1f1f; border-radius:10px; }
    button { margin-top:10px; padding:8px 12px; font-weight:700; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Tetris</h1>
    <canvas id="c" width="260" height="520"></canvas>
    <div id="status"></div>
    <button id="restart">Restart</button>
  </div>

<script>
(() => {
  const c = document.getElementById('c');
  const ctx = c.getContext('2d');
  const cols = 10, rows = 20, size = 26;
  let board, piece, score, dropId;

  const SHAPES = [
    [[1,1,1,1]],
    [[1,1],[1,1]],
    [[0,1,0],[1,1,1]],
    [[1,0,0],[1,1,1]],
    [[0,0,1],[1,1,1]],
    [[1,1,0],[0,1,1]],
    [[0,1,1],[1,1,0]]
  ];

  function reset() {
    board = Array.from({length: rows}, () => Array(cols).fill(0));
    score = 0;
    spawn();
    clearInterval(dropId);
    dropId = setInterval(tick, 500);
    updateStatus();
    draw();
  }

  function updateStatus() {
    document.getElementById('status').textContent = 'Score: ' + score;
  }

  function spawn() {
    const shape = SHAPES[Math.floor(Math.random()*SHAPES.length)];
    piece = {shape, x: 3, y: 0};
    if (collides(piece.x, piece.y, piece.shape)) {
      clearInterval(dropId);
    }
  }

  function rotate(shape) {
    const h = shape.length, w = shape[0].length;
    const out = Array.from({length: w}, () => Array(h).fill(0));
    for (let y=0;y<h;y++) for (let x=0;x<w;x++) out[x][h-1-y] = shape[y][x];
    return out;
  }

  function collides(px, py, shape) {
    for (let y=0;y<shape.length;y++) {
      for (let x=0;x<shape[0].length;x++) {
        if (!shape[y][x]) continue;
        const nx = px + x;
        const ny = py + y;
        if (nx < 0 || nx >= cols || ny >= rows) return true;
        if (ny >= 0 && board[ny][nx]) return true;
      }
    }
    return false;
  }

  function merge() {
    for (let y=0;y<piece.shape.length;y++) {
      for (let x=0;x<piece.shape[0].length;x++) {
        if (piece.shape[y][x]) board[piece.y + y][piece.x + x] = 1;
      }
    }
  }

  function clearLines() {
    let cleared = 0;
    for (let y=rows-1;y>=0;y--) {
      if (board[y].every(v => v)) {
        board.splice(y,1);
        board.unshift(Array(cols).fill(0));
        cleared++;
        y++;
      }
    }
    if (cleared) {
      score += cleared * 100;
      updateStatus();
    }
  }

  function tick() {
    if (!piece) return;
    if (!collides(piece.x, piece.y + 1, piece.shape)) {
      piece.y++;
    } else {
      merge();
      clearLines();
      spawn();
    }
    draw();
  }

  function draw() {
    ctx.clearRect(0,0,c.width,c.height);
    for (let y=0;y<rows;y++) for (let x=0;x<cols;x++) {
      if (board[y][x]) {
        ctx.fillStyle = '#1f1f1f';
        ctx.fillRect(x*size, y*size, size-1, size-1);
      }
    }

    if (piece) {
      ctx.fillStyle = '#d1495b';
      for (let y=0;y<piece.shape.length;y++) for (let x=0;x<piece.shape[0].length;x++) {
        if (piece.shape[y][x]) ctx.fillRect((piece.x + x)*size, (piece.y + y)*size, size-1, size-1);
      }
    }
  }

  window.addEventListener('keydown', (e) => {
    if (!piece) return;
    if (e.key === 'ArrowLeft' && !collides(piece.x-1, piece.y, piece.shape)) piece.x--;
    if (e.key === 'ArrowRight' && !collides(piece.x+1, piece.y, piece.shape)) piece.x++;
    if (e.key === 'ArrowDown' && !collides(piece.x, piece.y+1, piece.shape)) piece.y++;
    if (e.key === 'ArrowUp') {
      const rot = rotate(piece.shape);
      if (!collides(piece.x, piece.y, rot)) piece.shape = rot;
    }
    draw();
  });

  document.getElementById('restart').addEventListener('click', reset);
  reset();
})();
</script>
</body>
</html>
